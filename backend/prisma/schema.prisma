// Wouri Bot - Prisma Schema
// Database: PostgreSQL + pgvector (Supabase)

generator client {
  provider        = "prisma-client-js"
  output          = "../generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [vector]
}

// ============================================================================
// Users Table
// ============================================================================

model User {
  id                    String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  waId                  String    @unique @map("wa_id")
  phoneNumber           String?   @map("phone_number")
  preferredLanguage     String    @default("fr") @map("preferred_language")
  region                String?
  subscriptionStatus    String    @default("freemium") @map("subscription_status") // "freemium" | "premium" | "blocked"
  subscriptionEndDate   DateTime? @map("subscription_end_date")
  monthlyQuotaUsed      Int       @default(0) @map("monthly_quota_used")
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @default(now()) @updatedAt @map("updated_at")

  @@map("users")
}

// ============================================================================
// Documents Table (RAG Knowledge Base)
// ============================================================================

model Document {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  content   String   @db.Text
  // pgvector field (768 dimensions for sentence-transformers)
  // Note: Prisma doesn't natively support vector type, so we use Unsupported
  // or handle via raw SQL queries
  embedding String?  // Sera géré via raw SQL avec le type vector(768)
  metadata  Json?    @db.JsonB
  createdAt DateTime @default(now()) @map("created_at")

  @@map("documents")
}

// ============================================================================
// Conversations Table (WhatsApp Messages History)
// ============================================================================

model Conversation {
  id             String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  waId           String    @map("wa_id")
  messageId      String    @unique @map("message_id") // WhatsApp message ID
  messageType    String    @map("message_type") // "text" | "audio" | "image"
  userMessage    String    @map("user_message") @db.Text
  botResponse    String?   @map("bot_response") @db.Text
  language       String    @default("fr")
  region         String?
  feedbackCount  Int       @default(0) @map("feedback_count")
  averageRating  Decimal?  @map("average_rating") @db.Decimal(3, 2)
  modelUsed      String?   @map("model_used")
  tokensUsed     Int?      @map("tokens_used")
  responseTimeMs Int?      @map("response_time_ms")
  createdAt      DateTime  @default(now()) @map("created_at")

  feedback Feedback[]

  @@map("conversations")
}

// ============================================================================
// Feedback Table (Admin Feedback Loop)
// ============================================================================

model Feedback {
  id             String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId String?       @map("conversation_id") @db.Uuid
  waId           String        @map("wa_id")
  rating         Int?          // 1-5 stars
  comment        String?       @db.Text
  embedding      String?       // VECTOR(768) - managed via raw SQL
  isEmbedded     Boolean       @default(false) @map("is_embedded")
  createdAt      DateTime      @default(now()) @map("created_at")
  updatedAt      DateTime      @default(now()) @updatedAt @map("updated_at")

  conversation Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([waId])
  @@index([conversationId])
  @@map("feedback")
}

// ============================================================================
// Translations Table (Multilingual Dictionary)
// ============================================================================

model Translation {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sourceText      String   @map("source_text") @db.Text
  sourceLanguage  String   @map("source_language") // "fr" | "dioula" | "baoulé" | "en"
  targetLanguage  String   @map("target_language") // "fr" | "dioula" | "baoulé" | "en"
  translatedText  String   @map("translated_text") @db.Text
  context         String?  @db.Text
  verified        Boolean  @default(false)
  createdBy       String?  @map("created_by")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at")

  @@unique([sourceText, sourceLanguage, targetLanguage], map: "unique_translation")
  @@index([sourceLanguage, targetLanguage])
  @@map("translations")
}

// ============================================================================
// Notes sur pgvector
// ============================================================================

// Prisma ne supporte pas directement le type VECTOR de PostgreSQL.
// Solutions:
// 1. Utiliser des migrations SQL brutes pour créer la colonne avec le type VECTOR
// 2. Utiliser Prisma.$executeRaw pour les requêtes vectorielles
// 3. Le schéma Prisma définit `embedding` comme String?, mais en DB ce sera VECTOR(768)

// Exemple de migration SQL (créée manuellement):
// ```sql
// -- Enable pgvector extension
// CREATE EXTENSION IF NOT EXISTS vector;
//
// -- Alter documents table to add vector column
// ALTER TABLE documents
// ADD COLUMN embedding vector(768);
//
// -- Create HNSW index for fast vector search
// CREATE INDEX documents_embedding_idx
// ON documents USING hnsw (embedding vector_cosine_ops);
//
// -- Vector search function (appelée via Prisma.$queryRaw)
// CREATE OR REPLACE FUNCTION match_documents(
//   query_embedding vector(768),
//   match_threshold float DEFAULT 0.7,
//   match_count int DEFAULT 5,
//   filter jsonb DEFAULT '{}'::jsonb
// )
// RETURNS TABLE (
//   id uuid,
//   content text,
//   similarity float,
//   metadata jsonb
// )
// LANGUAGE plpgsql
// AS $$
// BEGIN
//   RETURN QUERY
//   SELECT
//     d.id,
//     d.content,
//     1 - (d.embedding <=> query_embedding) AS similarity,
//     d.metadata
//   FROM documents d
//   WHERE
//     1 - (d.embedding <=> query_embedding) > match_threshold
//     AND (filter = '{}'::jsonb OR d.metadata @> filter)
//   ORDER BY similarity DESC
//   LIMIT match_count;
// END;
// $$;
// ```
