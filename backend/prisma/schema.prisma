// Wouri Bot - Prisma Schema
// Database: PostgreSQL + pgvector (Supabase)

generator client {
  provider        = "prisma-client-js"
  output          = "../generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [vector]
}

// ============================================================================
// Users Table
// ============================================================================

model User {
  id                    String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  waId                  String    @unique @map("wa_id")
  phoneNumber           String?   @map("phone_number")
  preferredLanguage     String    @default("fr") @map("preferred_language")
  region                String?
  subscriptionStatus    String    @default("freemium") @map("subscription_status") // "freemium" | "premium" | "blocked"
  subscriptionEndDate   DateTime? @map("subscription_end_date")
  monthlyQuotaUsed      Int       @default(0) @map("monthly_quota_used")
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @default(now()) @updatedAt @map("updated_at")

  @@map("users")
}

// ============================================================================
// Documents Table (RAG Knowledge Base)
// ============================================================================

model Document {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  content   String   @db.Text
  // pgvector field (768 dimensions for sentence-transformers)
  // Note: Prisma doesn't natively support vector type, so we use Unsupported
  // or handle via raw SQL queries
  embedding String?  // Sera géré via raw SQL avec le type vector(768)
  metadata  Json?    @db.JsonB
  createdAt DateTime @default(now()) @map("created_at")

  @@map("documents")
}

// ============================================================================
// Conversations Table (WhatsApp Messages History)
// ============================================================================

model Conversation {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  waId        String   @map("wa_id")
  messageId   String   @unique @map("message_id") // WhatsApp message ID
  messageType String   @map("message_type") // "text" | "audio" | "image"
  userMessage String   @map("user_message") @db.Text
  botResponse String?  @map("bot_response") @db.Text
  language    String   @default("fr")
  region      String?
  createdAt   DateTime @default(now()) @map("created_at")

  @@map("conversations")
}

// ============================================================================
// Notes sur pgvector
// ============================================================================

// Prisma ne supporte pas directement le type VECTOR de PostgreSQL.
// Solutions:
// 1. Utiliser des migrations SQL brutes pour créer la colonne avec le type VECTOR
// 2. Utiliser Prisma.$executeRaw pour les requêtes vectorielles
// 3. Le schéma Prisma définit `embedding` comme String?, mais en DB ce sera VECTOR(768)

// Exemple de migration SQL (créée manuellement):
// ```sql
// -- Enable pgvector extension
// CREATE EXTENSION IF NOT EXISTS vector;
//
// -- Alter documents table to add vector column
// ALTER TABLE documents
// ADD COLUMN embedding vector(768);
//
// -- Create HNSW index for fast vector search
// CREATE INDEX documents_embedding_idx
// ON documents USING hnsw (embedding vector_cosine_ops);
//
// -- Vector search function (appelée via Prisma.$queryRaw)
// CREATE OR REPLACE FUNCTION match_documents(
//   query_embedding vector(768),
//   match_threshold float DEFAULT 0.7,
//   match_count int DEFAULT 5,
//   filter jsonb DEFAULT '{}'::jsonb
// )
// RETURNS TABLE (
//   id uuid,
//   content text,
//   similarity float,
//   metadata jsonb
// )
// LANGUAGE plpgsql
// AS $$
// BEGIN
//   RETURN QUERY
//   SELECT
//     d.id,
//     d.content,
//     1 - (d.embedding <=> query_embedding) AS similarity,
//     d.metadata
//   FROM documents d
//   WHERE
//     1 - (d.embedding <=> query_embedding) > match_threshold
//     AND (filter = '{}'::jsonb OR d.metadata @> filter)
//   ORDER BY similarity DESC
//   LIMIT match_count;
// END;
// $$;
// ```
